import { Layout } from "components/api-doc"
import { R, Method, Fn, Member, Decl, Item, NthBit } from "components/tyfmt"
import { number, boolean, map, set, array, iterable, Data, Ot, Tag, Sigma, Thunk } from "components/exports"
import { app, optional, tuple, readonly, pi, record } from "components/tycon"
export default Layout

# Gsub and Gpos

## Common Structure (Namespace <Decl s={Ot.GsubGpos}/>)

### Datatype <Decl s={Ot.GsubGpos.TableT("L")}/>

#### Properties

* <Member s={Ot.GsubGpos.TableT.scripts} type={map(Tag, Ot.GsubGpos.ScriptT("L"))}/>
* <Member s={Ot.GsubGpos.TableT.features} type={array(Ot.GsubGpos.FeatureT("L"))}/>
* <Member s={Ot.GsubGpos.TableT.lookups} type={array("L")}/>
* <Member s={Ot.GsubGpos.TableT.featureVariations} type={Data.Maybe(array(Ot.GsubGpos.FeatureVariationT("L")))}/>

### Datatype <Decl s={Ot.GsubGpos.ScriptT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.ScriptT.defaultLanguage} type={Data.Maybe(Ot.GsubGpos.LanguageT("L"))}/>
* <Member s={Ot.GsubGpos.ScriptT.languages} type={map(Tag,Ot.GsubGpos.LanguageT("L"))}/>

### Datatype <Decl s={Ot.GsubGpos.LanguageT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.LanguageT.requiredFeature} type={Data.Maybe(Ot.GsubGpos.FeatureT("L"))}/>
* <Member s={Ot.GsubGpos.LanguageT.features} type={array(Ot.GsubGpos.FeatureT("L"))}/>

### Datatype <Decl s={Ot.GsubGpos.FeatureT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.FeatureT.tag} type={Tag}/>
* <Member s={Ot.GsubGpos.FeatureT.lookups} type={array("L")}/>
* <Member s={Ot.GsubGpos.FeatureT.params} type={optional(Data.Maybe(Sigma.DependentPair))}/>

### Datatype <Decl s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.AxisRangeCondition}/>, <Decl s={Ot.Gpos.AxisRangeCondition}/>.

#### Members

* <Member s={Ot.GsubGpos.AxisRangeCondition.dim} type={Ot.Var.Dim}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.min} type={number}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.max} type={number}/>

### Type Alias <Decl s={Ot.GsubGpos.FeatureVariationCondition}/> = <R s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.FeatureVariationCondition}/>, <Decl s={Ot.Gpos.FeatureVariationCondition}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureVariationT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.FeatureVariationT.conditions} type={array(Ot.GsubGpos.FeatureVariationCondition)}/>
* <Member s={Ot.GsubGpos.FeatureVariationT.substitutions} type={map(Ot.GsubGpos.FeatureT("L"), Ot.GsubGpos.FeatureT("L"))}/>

### Interface <Decl s={Ot.GsubGpos.LookupProp}/>

Aliased as <Decl s={Ot.Gsub.LookupProp}/>, <Decl s={Ot.Gpos.LookupProp}/>.

#### Properties

* <Member s={Ot.GsubGpos.LookupProp.rightRoLeft} type={boolean}/>
* <Member s={Ot.GsubGpos.LookupProp.ignoreGlyphs} type={Data.Maybe(set(Ot.Glyph))}/>


## Namespace <Decl s={Ot.Gsub}/>

### Constant <Decl s={Ot.Gsub.Tag}/> = `"GSUB"`

### Type <Decl s={Ot.Gsub.Table} />

#### Inherits

* <R s={Ot.GsubGpos.TableT(Ot.Gsub.Lookup)}/>

#### Factory Methods

* <Method static long s={Ot.Gsub.Table.create} args={{
    scripts:optional(map(Tag,Ot.Gsub.Script)),
    features:optional(array(Ot.Gsub.Feature)),
    lookups:optional(array(Ot.Gsub.Lookup)),
    featureVariations:optional(Data.Maybe(Ot.Gsub.FeatureVariation)),
    }}/>

### Datatype <Decl s={Ot.Gsub.Script}/>

Defined as <R s={Ot.GsubGpos.ScriptT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.Language}/>

Defined as <R s={Ot.GsubGpos.LanguageT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.Feature}/>

Defined as <R s={Ot.GsubGpos.FeatureT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.FeatureVariation}/>

Defined as <R s={Ot.GsubGpos.FeatureVariationT(Ot.Gsub.Lookup)}/>

### Type <Decl s={Ot.Gsub.Lookup} />

Defined as <R s={Ot.Gsub.LookupT(record({ref:Ot.Gsub.Lookup}))}/>

### Type <Decl s={Ot.Gsub.LookupT("E")} />

Defined as a union of the following cases:

* <R s={Ot.Gsub.Single}/>
* <R s={Ot.Gsub.Multiple}/>
* <R s={Ot.Gsub.Alternate}/>
* <R s={Ot.Gsub.Ligature}/>
* <R s={Ot.Gsub.ChainingT("E")}/>
* <R s={Ot.Gsub.ReverseSub}/>

#### Properties

* <Member readonly s={Ot.Gsub.LookupT.type} type="unique symbol"/>

### Case Type <Decl s={Ot.Gsub.Single}/> | type = <R s={Ot.Gsub.LookupType.Single}/>

#### Inherits

* <R s={Ot.Gsub.SingleProp}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Single.create} args={{props:optional(Ot.Gsub.SingleProp)}}/>

### Datatype <Decl s={Ot.Gsub.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.SingleProp.mapping} type={map(Ot.Glyph, Ot.Glyph)}/>

### Case Type <Decl s={Ot.Gsub.Multiple}/> | type = <R s={Ot.Gsub.LookupType.Multiple}/>

#### Inherits

* <R s={Ot.Gsub.MultipleAlternateProp}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Multiple.create} args={{props:optional(Ot.Gsub.MultipleAlternateProp)}}/>

### Case Type <Decl s={Ot.Gsub.Alternate}/> | type = <R s={Ot.Gsub.LookupType.Alternate}/>

#### Inherits

* <R s={Ot.Gsub.MultipleAlternateProp}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Alternate.create} args={{props:optional(Ot.Gsub.MultipleAlternateProp)}}/>

### Datatype <Decl s={Ot.Gsub.MultipleAlternateProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.MultipleAlternateProp.mapping} type={map(Ot.Glyph, readonly(array(Ot.Glyph)))}/>

### Case Type <Decl s={Ot.Gsub.Ligature}/> | type = <R s={Ot.Gsub.LookupType.Ligature}/>

#### Inherits

* <R s={Ot.Gsub.LigatureProp}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Ligature.create}  args={{props:optional(Ot.Gsub.LigatureProp)}}/>

### Datatype <Decl s={Ot.Gsub.LigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.LigatureProp.mapping} type={array(Ot.Gsub.LigatureEntry)}/>

### Datatype <Decl s={Ot.Gsub.LigatureEntry}/>

#### Properties

* <Member readonly s={Ot.Gsub.LigatureEntry.from} type={readonly(array(Ot.Glyph))}/>
* <Member readonly s={Ot.Gsub.LigatureEntry.to} type={Ot.Glyph}/>

### Type <Decl s={Ot.Gsub.Chaining}/>

Defined as <R s = {Ot.Gsub.ChainingT(record({ref:Ot.Gsub.Lookup}))}/>.

#### Factory Methods

* <Method static s={Ot.Gsub.Chaining.create} args={{props:optional(Ot.GsubGpos.ChainingProp(record({ref:Ot.Gsub.Lookup})))}}/>

### Case Type <Decl s={Ot.Gsub.ChainingT("E")}/> | type = <R s={Ot.Gsub.LookupType.Chaining}/>

#### Inherits

* <R s={Ot.GsubGpos.ChainingProp("E")}/>

### Case Type <Decl s={Ot.Gsub.ReverseSub}/> | type = <R s={Ot.Gsub.LookupType.ReverseSub}/>

#### Inherits

* <R s={Ot.Gsub.ReverseSubProp}/>

#### Factory Methods

* <Method static s={Ot.Gsub.ReverseSub.create} args={{props:optional(Ot.Gsub.ReverseSubProp)}}/>

### Datatype <Decl s={Ot.Gsub.ReverseSubProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.ReverseSubProp.rules} type={array(Ot.Gsub.ReverseRule)}/>

### Datatype <Decl s={Ot.Gsub.ReverseRule}/>

#### Properties

* <Member s={Ot.Gsub.ReverseRule.match} type={set(Ot.Glyph)}/>
* <Member s={Ot.Gsub.ReverseRule.doSubAt} type={number}/>
* <Member s={Ot.Gsub.ReverseRule.replacement} type={map(Ot.Glyph,Ot.Glyph)}/>





## Namespace <Decl s={Ot.Gpos}/>

### Constant <Decl s={Ot.Gpos.Tag}/> = `"GPOS"`

### Type <Decl s={Ot.Gpos.Table} />

#### Inherits

* <R s={Ot.GsubGpos.TableT(Ot.Gpos.Lookup)}/>

#### Factory Methods

* <Method static long s={Ot.Gpos.Table.create} args={{
    scripts:optional(map(Tag,Ot.Gpos.Script)),
    features:optional(array(Ot.Gpos.Feature)),
    lookups:optional(array(Ot.Gpos.Lookup)),
    featureVariations:optional(Data.Maybe(Ot.Gpos.FeatureVariation)),
    }}/>

### Datatype <Decl s={Ot.Gpos.Script}/>

Defined as <R s={Ot.GsubGpos.ScriptT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.Language}/>

Defined as <R s={Ot.GsubGpos.LanguageT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.Feature}/>

Defined as <R s={Ot.GsubGpos.FeatureT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.FeatureVariation}/>

Defined as <R s={Ot.GsubGpos.FeatureVariationT(Ot.Gpos.Lookup)}/>

### Type <Decl s={Ot.Gpos.Lookup} />

Defined as <R s={Ot.Gpos.LookupT(record({ref:Ot.Gpos.Lookup}))}/>

### Type <Decl s={Ot.Gpos.LookupT("E")} />

Defined as a union of the following cases:

* <R s={Ot.Gpos.Single}/>
* <R s={Ot.Gpos.Pair}/>
* <R s={Ot.Gpos.Cursive}/>
* <R s={Ot.Gpos.MarkToBase}/>
* <R s={Ot.Gpos.MarkToLigature}/>
* <R s={Ot.Gpos.MarkToMark}/>
* <R s={Ot.Gpos.ChainingT("E")}/>

#### Properties

* <Member readonly s={Ot.Gsub.LookupT.type} type="unique symbol"/>

### Case Type <Decl s={Ot.Gpos.Single}/> | type = <R s={Ot.Gpos.LookupType.Multiple}/>

#### Inherits

* <R s={Ot.Gpos.SingleProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Single.create} args={{props:optional(Ot.Gpos.SingleProp)}} />

### Datatype <Decl s={Ot.Gpos.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.SingleProp.adjustments} type={map(Ot.Glyph, Ot.Gpos.Adjustment)}/>

### Case Type <Decl s={Ot.Gpos.Pair}/> | type = <R s={Ot.Gpos.LookupType.Pair}/>

#### Inherits

* <R s={Ot.Gpos.PairProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Pair.create} args={{props:optional(Ot.Gpos.PairProp)}} />

### Datatype <Decl s={Ot.Gpos.PairProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.PairProp.adjustments} type={Ot.DicingStore(Ot.Glyph,Ot.Glyph,Ot.Gpos.AdjustmentPair)}/>

### Case Type <Decl s={Ot.Gpos.Cursive}/> | type = <R s={Ot.Gpos.LookupType.Cursive}/>

#### Inherits

* <R s={Ot.Gpos.CursiveProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Cursive.create} args={{props:optional(Ot.Gpos.CursiveProp)}} />

### Datatype <Decl s={Ot.Gpos.CursiveProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.CursiveProp.attachments} type={map(Ot.Glyph,Ot.Gpos.CursiveAnchorPair)}/>

### Case Type <Decl s={Ot.Gpos.MarkToBase}/> | type = <R s={Ot.Gpos.LookupType.MarkToBase}/>

#### Inherits

* <R s={Ot.Gpos.MarkToBaseProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToBase.create} args={{props:optional(Ot.Gpos.MarkToBaseProp)}} />

### Datatype <Decl s={Ot.Gpos.MarkToBaseProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToBaseProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToBaseProp.bases} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Case Type <Decl s={Ot.Gpos.MarkToLigature}/> | type = <R s={Ot.Gpos.LookupType.MarkToLigature}/>

#### Inherits

* <R s={Ot.Gpos.MarkToLigatureProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToLigature.create} args={{props:optional(Ot.Gpos.MarkToLigatureProp)}} />

### Datatype <Decl s={Ot.Gpos.MarkToLigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToLigatureProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToLigatureProp.bases} type={map(Ot.Glyph,Ot.Gpos.LigatureBaseRecord)}/>

### Case Type <Decl s={Ot.Gpos.MarkToMark}/> | type = <R s={Ot.Gpos.LookupType.MarkToMark}/>

#### Inherits

* <R s={Ot.Gpos.MarkToMarkProp}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToMark.create} args={{props:optional(Ot.Gpos.MarkToMarkProp)}} />

### Datatype <Decl s={Ot.Gpos.MarkToMarkProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToMarkProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToMarkProp.baseMarks} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Type <Decl s={Ot.Gpos.Chaining}/>

Defined as <R s={Ot.Gpos.ChainingT(record({ref:Ot.Gpos.Lookup}))}/>.

#### Factory Methods

* <Method static s={Ot.Gpos.Chaining.create}  args={{props:optional(Ot.GsubGpos.ChainingProp(record({ref:Ot.Gpos.Lookup})))}}/>

### Case Type <Decl s={Ot.Gpos.ChainingT("E")}/> | type = <R s={Ot.Gpos.LookupType.Chaining}/>

#### Inherits

* <R s={Ot.GsubGpos.ChainingProp("E")}/>



## Shared Chaining Lookup

### Datatype <Decl s={Ot.GsubGpos.ChainingProp("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingProp("E")}/>, <Decl s={Ot.Gpos.ChainingProp("E")}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingProp.rules} type={array(Ot.GsubGpos.ChainingRule("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingRule("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingRule("E")}/>, <Decl s={Ot.Gpos.ChainingRule("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingRule.match} type={array(set(Ot.Glyph))}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputBegins} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputEnds} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.applications} type={array(Ot.GsubGpos.ChainingApplication("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingApplication("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingApplication("E")}/>, <Decl s={Ot.Gpos.ChainingApplication("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingApplication.at} type={number}/>
* <Member s={Ot.GsubGpos.ChainingApplication.apply} type="E"/>






## Shared GSUB + GPOS Support Types

### Type <Decl s={Ot.GsubGpos.Coverage}/> = <R s={set(Ot.Glyph)}/>

Also aliased as <Decl s={Ot.Gsub.Coverage}/>, <Decl s={Ot.Gpos.Coverage}/>

### Type <Decl s={Ot.GsubGpos.ClassDef}/> = <R s={map(Ot.Glyph,number)}/>

Also aliased as <Decl s={Ot.Gsub.ClassDef}/>, <Decl s={Ot.Gpos.ClassDef}/>

### Datatype <Decl s={Ot.Gpos.Adjustment}/>

#### Properties
* <Member readonly s={Ot.Gpos.Adjustment.dX} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dXDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dY} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dYDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidth} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidthDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeight} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeightDevice} type={optional(Data.Maybe(readonly(array(number))))}/>

### Datatype <Decl s={Ot.Gpos.AdjustmentPair}/> = <R s={tuple(Ot.Gpos.Adjustment,Ot.Gpos.Adjustment)}/>

### Datatype <Decl s={Ot.Gpos.Anchor}/>

#### Properties
* <Member readonly s={Ot.Gpos.Anchor.x} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.xDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Anchor.y} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.yDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gdef.Anchor.pointAttachment} type={optional(Data.Maybe(Ot.Gdef.PointIDRef))}/>

### Datatype <Decl s={Ot.Gpos.CursiveAnchorPair}/>

#### Properties
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.entry} type={Data.Maybe(Ot.Gpos.Anchor)}/>
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.exit} type={Data.Maybe(Ot.Gpos.Anchor)}/>

### Datatype <Decl s={Ot.Gpos.MarkRecord}/>

#### Properties
* <Member s={Ot.Gpos.MarkRecord.markAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.BaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.BaseRecord.baseAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.LigatureBaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.LigatureBaseRecord.baseAnchors} type={array(array(Data.Maybe(Ot.Gpos.Anchor)))}/>





## Feature Parameters (<Decl s={Ot.GsubGpos.FeatureParams}/>)

This namespace is aliased as <Decl s={Ot.Gsub.FeatureParams}/> and <Decl s={Ot.Gpos.FeatureParams}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureParams.StylisticSet}/>

#### Type ID

* <Decl s={Ot.GsubGpos.FeatureParams.TID_StylisticSet}/>

#### Members

* <Member readonly s={Ot.GsubGpos.FeatureParams.StylisticSet.uiNameID} type={number}/>


## Dicing Store

### Opaque Type <Decl s={Ot.DicingStore("X","Y","D")}/>

#### Methods

* <Method s={Ot.DicingStore.get} args={{x:"X",y:"Y"}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getByClass} args={{cx:number,cy:number}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getXClassDef} returns={array(array("X"))}/>
* <Method s={Ot.DicingStore.getYClassDef} returns={array(array("Y"))}/>
* <Method s={Ot.DicingStore.entries} returns={app("IterableIterator",tuple("X","Y",Data.Maybe("D")))}/>
* <Method s={Ot.DicingStore.set} args={{x:iterable("X"),y:iterable("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.setIfAbsent} args={{x:iterable("X"),y:iterable("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.update} args={{x:iterable("X"),y:iterable("Y"),fn:pi({original:Data.Maybe("D")},Data.Maybe("D"))}} returns="void"/>